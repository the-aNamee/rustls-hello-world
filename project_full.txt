.
├── ca.key
├── ca.pem
├── Cargo.lock
├── Cargo.toml
├── client_options.ron
├── .gitignore
├── project_full.txt
├── server.crt
├── server.csr
├── server.key
├── server_options.ron
└── src
    ├── bin
    │   ├── client.rs
    │   └── server.rs
    └── lib.rs

2 directories, 14 files
===== ./Cargo.toml =====
[package]
name = "rustls-hello-world"
version = "0.1.0"
edition = "2024"

[dependencies]
rustls = "0.23.34"
tokio = { version = "1.48.0", features = ["full"] }
serde = { version = "1.0.219", features = ["derive"] }
anyhow = "1.0.100"
tokio-rustls = "0.26.4"
futures = "0.3.31"
rustls-pemfile = "2.2.0"
argh = "0.1.13"
dotenv = "0.15.0"
ron = "0.11.0"
webpki-roots = "1.0.3"


===== ./client_options.ron =====
(
    host: "127.0.0.1",
    port: 8443,
    domain: Some("localhost"),
    cafile: Some("cert.pem"),
)


===== ./server_options.ron =====
(
    addr: "127.0.0.1:8443",
    cert: "cert.pem",
    key: "key.pem",
    echo_mode: false,
)


===== ./src/bin/client.rs =====
use std::{io, net::ToSocketAddrs, path::PathBuf, sync::Arc};

use rustls::pki_types::{CertificateDer, ServerName, pem::PemObject};
use serde::Deserialize;
use tokio::{
    fs,
    io::{AsyncWriteExt, copy, split, stdin, stdout},
    net::TcpStream,
};
use tokio_rustls::TlsConnector;

#[derive(Deserialize)]
struct ClientOptions {
    /// Host
    host: String,
    /// Port
    port: u16,
    /// Domain
    domain: Option<String>,
    /// Cafile
    cafile: Option<PathBuf>,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let options: ClientOptions = ron::from_str(&fs::read_to_string("client_options.ron").await?)?;

    let addr = (options.host.as_str(), options.port)
        .to_socket_addrs()?
        .next()
        .ok_or_else(|| io::ErrorKind::NotFound)
        .expect("There was a problematic problem.");
    let domain = options.domain.unwrap_or(options.host);
    let content = format!("GET / HTTP/1.0\r\nHost: {}\r\n\r\n", domain);

    let mut root_cert_store = rustls::RootCertStore::empty();
    if let Some(cafile) = &options.cafile {
        for cert in CertificateDer::pem_file_iter(cafile)? {
            root_cert_store.add(cert?)?;
        }
    } else {
        root_cert_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());
    }

    let config = rustls::ClientConfig::builder()
        .with_root_certificates(root_cert_store)
        .with_no_client_auth();
    let connector = TlsConnector::from(Arc::new(config));

    let stream = TcpStream::connect(&addr).await?;

    let (mut stdin, mut stdout) = (stdin(), stdout());

    let domain = ServerName::try_from(domain.as_str())?.to_owned();
    let mut stream = connector.connect(domain, stream).await?;
    stream.write_all(content.as_bytes()).await?;

    let (mut reader, mut writer) = split(stream);

    tokio::select! {
        ret = copy(&mut reader, &mut stdout) => {
            ret?;
        },
        ret = copy(&mut stdin, &mut writer) => {
            ret?;
            writer.shutdown().await?
        }
    }

    Ok(())
}


===== ./src/bin/server.rs =====
use std::{
    io::{self, Error as IoError},
    net::ToSocketAddrs,
    path::PathBuf,
    sync::Arc,
};

use anyhow::Result;
use rustls::pki_types::{CertificateDer, PrivateKeyDer, pem::PemObject};
use serde::Deserialize;
use tokio::{
    fs,
    io::{AsyncWriteExt, copy, sink, split},
    net::TcpListener,
};
use tokio_rustls::TlsAcceptor;

#[derive(Deserialize)]
struct ServerOptions {
    /// bind addr
    addr: String,
    /// cert file
    cert: PathBuf,
    /// key file
    key: PathBuf,
    /// echo mode
    echo_mode: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let server_options: ServerOptions =
        ron::from_str(&fs::read_to_string("server_options.ron").await?)?;

    let addr = server_options
        .addr
        .to_socket_addrs()?
        .next()
        .ok_or_else(|| IoError::from(io::ErrorKind::AddrNotAvailable))?;
    let certs =
        CertificateDer::pem_file_iter(&server_options.cert)?.collect::<Result<Vec<_>, _>>()?;
    let key = PrivateKeyDer::from_pem_file(&server_options.key)?;
    let flag_echo = server_options.echo_mode;

    let config = rustls::ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    let acceptor = TlsAcceptor::from(Arc::new(config));

    let listener = TcpListener::bind(&addr).await?;

    loop {
        let (stream, peer_addr) = listener.accept().await?;
        let acceptor = acceptor.clone();

        let fut = async move {
            let mut stream = acceptor.accept(stream).await?;

            if flag_echo {
                let (mut reader, mut writer) = split(stream);
                let n = copy(&mut reader, &mut writer).await?;
                writer.flush().await?;
                println!("Echo: {} - {}", peer_addr, n);
            } else {
                let mut output = sink();
                stream
                    .write_all(
                        &b"HTTP/1.0 200 ok\r\n\
                                    Connection: close\r\n\
                                    Content-length: 12\r\n\
                                    \r\n\
                                    Hello world!"[..],
                    )
                    .await?;
                stream.shutdown().await?;
                copy(&mut stream, &mut output).await?;
                println!("Hello: {}", peer_addr);
            }

            Ok(()) as io::Result<()>
        };

        tokio::spawn(async move {
            if let Err(err) = fut.await {
                eprintln!("{:?}", err);
            }
        });
    }
}


===== ./src/lib.rs =====



